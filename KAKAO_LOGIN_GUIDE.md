# 카카오 간편 로그인 사용 가이드 (DB 없이)

> 목표: **별도의 회원가입/로그인 DB를 만들지 않고**, 카카오 계정으로만 로그인해서 우리 서비스에서 “로그인된 사용자”로 취급하기.
>
> 전제: 이 저장소는 FastAPI 기반 백엔드 구조로 보이며, 프론트엔드(웹/앱)에서 카카오 로그인 UI를 띄우고 **백엔드는 카카오 토큰을 검증**한 뒤 **우리 서비스용 세션/JWT를 발급**하는 방식이 일반적입니다.

---

## 0) 핵심 개념 (DB 없이 가능한가?)

가능합니다. 다만 **“우리 DB에 회원 레코드가 0개”**인 상태에서 할 수 있는 것은 아래처럼 정리됩니다.

- **가능**
  - 카카오 로그인으로 사용자 식별 (대표 식별자: `id` = Kakao user id)
  - 카카오에서 받아온 **Access Token**을 서버에서 검증(사실상 “카카오에 물어봐서” 유효성 확인)
  - 우리 서비스용 **JWT/세션** 발급 (DB 없이도 가능)
  - 로그인/로그아웃(토큰 폐기) 및 카카오 연결해제(unlink)

- **제약**
  - 사용자 프로필(닉네임 등)을 **서버에서 영구 저장**하지 않으므로, 요청마다 카카오에서 다시 조회하거나(느림/쿼터) 프론트가 들고 있어야 함
  - 사용자별 설정/즐겨찾기/히스토리 같은 기능은 결국 저장소(DB/Redis/S3 등)가 필요
  - “우리 서비스에서 차단/권한/등급” 같은 사용자 관리도 DB 없이 제한적

즉, **인증(Authentication)** 만 카카오로 맡기고, **인가(Authorization)** 와 사용자 상태/데이터는 저장하지 않는 형태로 시작할 수 있습니다.

---

## 1) 카카오 로그인 흐름 선택 (추천 2가지)

카카오 개발자 문서의 JS SDK 기반 로그인은 보통 프론트에서 진행됩니다. 백엔드는 다음 중 한 방식으로 “로그인 완료”를 판단합니다.

### A안(권장): 프론트가 카카오 로그인 → Access Token을 백엔드로 전달 → 백엔드가 카카오 API로 검증

1. 프론트(웹)가 **Kakao JS SDK**로 로그인
2. 프론트가 획득한 `access_token`을 백엔드로 전송
3. 백엔드는 카카오 API `GET /v2/user/me` 호출로 토큰이 유효한지 확인
4. 백엔드는 우리 서비스용 **JWT**(또는 세션 쿠키)를 발급해서 프론트에 전달

**장점**

- 구현이 직관적
- 백엔드는 토큰 검증/우리 토큰 발급만 하면 됨

**주의**

- 프론트에서 받은 `access_token`을 그대로 우리 API 인증 토큰으로 쓰지 말 것
  - 우리 API 인증은 **우리 JWT**로 하고, 카카오 토큰은 “검증용”으로만 사용 권장

### B안(서버 주도): Authorization Code(인가 코드) 를 백엔드가 받아서 토큰 교환

1. 사용자가 카카오 인증 화면에서 동의
2. 카카오가 `redirect_uri`로 `code`(인가 코드)를 전달
3. 백엔드가 `code`로 카카오 토큰 엔드포인트에 요청하여 `access_token` 발급
4. 백엔드가 `GET /v2/user/me`로 사용자 확인 후 우리 JWT 발급

**장점**

- 토큰 교환 과정이 서버에서 일어나서 보안적으로 깔끔

**주의**

- 프론트 라우팅/리다이렉트 설계가 필요

> 결론: 웹 프론트가 이미 있는 상태면 **A안이 가장 빠른 시작**입니다.

---

## 2) 카카오 개발자 콘솔에서 해야 할 설정

### 2.1 애플리케이션 생성

- 카카오 디벨로퍼스에서 앱 생성

### 2.2 앱 키 확인

- **JavaScript 키**: 웹 프론트에서 Kakao JS SDK 초기화에 사용
- **REST API 키**: 백엔드에서 토큰 교환/REST 호출에 사용(주로 B안)
- (필요 시) **Admin 키**: 민감. 서버 전용이며 깃에 절대 커밋 금지

### 2.3 플랫폼 등록(웹)

- [내 애플리케이션] → [플랫폼] → [Web]
- 서비스 도메인 등록
  - 로컬 개발: 예) `http://localhost:3000`
  - 운영: 예) `https://your-domain.com`

### 2.4 Redirect URI 등록 (B안을 쓸 경우 필수)

- [카카오 로그인] → [Redirect URI]
- 예) `https://your-domain.com/auth/kakao/callback`

### 2.5 카카오 로그인 활성화

- [카카오 로그인] ON
- 동의항목(프로필/이메일 등) 필요한 것만 선택

---

## 3) 프론트엔드(웹)에서의 사용(개념)

카카오 JS SDK로 로그인 버튼을 만들고, 로그인 성공 시 **Access Token**을 얻습니다.

- 초기화에 **JavaScript 키**가 필요
- 로그인 성공 시 `access_token` 획득
- 그 토큰을 우리 백엔드에 전달

백엔드에 넘기는 요청 예시(개념):

```http
POST /auth/kakao
Content-Type: application/json

{ "kakao_access_token": "..." }
```

---

## 3-1) 모바일(앱)에서의 사용(개념) — Android/iOS

모바일 앱에서는 보통 **카카오 SDK(안드로이드/아이폰)** 를 사용해 로그인합니다. 흐름은 웹과 동일하게,

1. 앱에서 카카오 로그인 성공 → `kakao_access_token` 획득
2. 앱이 백엔드 `POST /auth/kakao`로 `kakao_access_token` 전달
3. 백엔드가 카카오 `GET /v2/user/me`로 검증
4. 백엔드가 **우리 서비스용 JWT** 발급 → 앱은 이후 우리 API 호출 시 우리 JWT 사용

### A. 앱에서 카카오 로그인(토큰 획득) 흐름

카카오 SDK는 대개 아래 로그인 방식을 자동으로 처리합니다.

- **카카오톡 앱이 설치되어 있으면**: 카카오톡으로 로그인(가장 UX 좋음)
- **카카오톡이 없으면**: 웹/브라우저 기반 로그인(카카오계정 로그인)

로그인 성공 시 앱은 보통 다음을 얻습니다.

- `access_token` (필수)
- `refresh_token` (SDK/권한/설정에 따라 제공)
- `expires_in` 등 만료 정보

> 백엔드 인증을 위해 꼭 필요한 것은 최소한 `access_token` 하나입니다.

### B. 앱에서 백엔드로 무엇을 보내나?

권장 페이로드(최소):

```http
POST /auth/kakao
Content-Type: application/json

{ "kakao_access_token": "..." }
```

주의:

- 앱이 `kakao_user_id` 같은 값을 같이 보내더라도, 백엔드는 **반드시 카카오 `user/me` 응답의 `id`를 기준으로** 사용자 식별을 확정해야 합니다.

### C. 백엔드에서 검증 후, 우리 JWT를 왜 또 발급하나?

모바일 앱에서 받은 카카오 토큰을 그대로 우리 API 인증에 쓰면 다음 문제가 생깁니다.

- 우리 API 권한/정책(역할, 차단 등)을 토큰 하나로 통제하기 어렵습니다.
- 우리 서비스가 카카오 장애/지연에 너무 의존합니다.
- 토큰 포맷/만료 정책이 우리 요구사항과 다를 수 있습니다.

그래서 일반적으로는:

- 카카오 토큰은 **로그인 시 1회 검증 용도**
- 우리 API 인증은 **우리 JWT**

---

## 3-2) Flutter에서 카카오 로그인 붙이기(개념/체크리스트)

Flutter에서는 보통 **Kakao Flutter SDK**(공식 패키지)로 로그인합니다.

### 1) 준비물 (카카오 콘솔)

- 카카오 디벨로퍼스에서 앱 생성
- 앱 키 확인
  - Flutter 앱 로그인에는 보통 **Native App Key**(네이티브 앱 키)를 씁니다.
- 플랫폼 등록
  - Android / iOS 각각 번들ID/패키지명을 등록

### 2) Flutter 패키지 선택

가장 흔한 선택은 공식 SDK 계열 패키지입니다.

- 패키지 예: `kakao_flutter_sdk_user`

> 실제 패키지/버전은 수시로 변할 수 있으니, 적용 전 pub.dev에서 “공식” 여부와 최신 설치 가이드를 확인하세요.

### 3) SDK 초기화(앱 시작 시 1회)

앱 시작 시점(예: `main()` 또는 앱 초기화 구간)에 네이티브 앱 키로 초기화합니다.

- 입력: `nativeAppKey`

### 4) 로그인 구현(토큰 획득)

Flutter 앱에서는 보통 아래 순서로 시도합니다.

1. 카카오톡이 설치되어 있으면 `loginWithKakaoTalk()`
2. 실패/미설치면 `loginWithKakaoAccount()` (카카오계정 웹 로그인)

성공하면 `OAuthToken` 같은 객체로 아래 값을 얻습니다.

- `accessToken`
- (있다면) `refreshToken`
- 만료 시간 정보

### 5) 백엔드로 토큰 전달(인증 완료의 핵심)

앱이 얻은 카카오 `accessToken`을 백엔드로 전달합니다.

```http
POST /auth/kakao
Content-Type: application/json

{ "kakao_access_token": "..." }
```

백엔드 역할:

- 이 토큰을 들고 카카오 `GET /v2/user/me` 호출
- 200이면 응답의 `id`(카카오 사용자 고유 ID)로 사용자 확정
- 우리 서비스용 JWT 발급 후 반환

### 6) 이후 API 호출은 “우리 JWT”로

로그인 이후부터는 아래처럼 운영하는 것이 안정적입니다.

- 앱 → 우리 API: `Authorization: Bearer <our_jwt>`
- 카카오 API는 필요할 때만(프로필 갱신 등) 직접 호출

### 7) 로그아웃/연결해제

- 앱 로그아웃(우리 서비스): 우리 JWT 삭제
- 카카오 로그아웃: SDK 제공 logout 호출(카카오 토큰 무효화)
- 연결해제(unlink): 사용자 탈퇴 UX에서 사용

### 8) Android/iOS에서 자주 막히는 설정 포인트(요약)

- Android
  - 앱 서명키 해시(Key Hash) 등록이 필요한 케이스가 있습니다(카카오 콘솔 안내에 따름).
  - 패키지명/서명키가 환경(디버그/릴리즈)마다 다르면 각각 등록이 필요할 수 있습니다.

- iOS
  - URL Scheme(카카오톡 앱으로 돌아오기 위한 스킴) 설정이 필요할 수 있습니다.
  - 번들 ID가 카카오 콘솔의 iOS 설정과 정확히 일치해야 합니다.

> 위 설정은 “카카오톡 앱으로 로그인”에서 특히 영향을 많이 받습니다. 카카오톡 로그인이 계속 실패하면, 먼저 `loginWithKakaoAccount()`로 우회가 되는지 확인하면 원인 분리가 쉽습니다.

---

## 4) 백엔드에서 해야 하는 일 (DB 없이 운영 가능한 최소 구성)

백엔드는 “카카오 토큰이 진짜인지”를 확인하고, 우리 서비스에서 쓸 **자체 인증 수단**을 발급합니다.

### 4.1 카카오 토큰 검증(사실상 조회)

가장 흔한 방식은 `GET /v2/user/me` 입니다.

- 요청
  - `Authorization: Bearer {access_token}`

- 응답에서 확인할 핵심
  - `id` (Kakao user id) ← **우리 서비스에서의 유일 사용자 식별자로 사용**
  - (선택) `kakao_account.email` 등

cURL 예시:

```bash
curl -X GET "https://kapi.kakao.com/v2/user/me" \
  -H "Authorization: Bearer ${KAKAO_ACCESS_TOKEN}"
```

**검증 로직 개념**

- 200 OK면 유효
- 401/403이면 만료/무효 → 프론트에 재로그인 유도

> DB가 없으므로, 백엔드는 이 `id`를 기반으로 우리 JWT에 `sub`(subject) 같은 클레임으로 담아 발급하는 패턴이 좋습니다.

### 4.2 우리 서비스용 JWT(또는 세션) 발급

카카오 토큰은 카카오 리소스 접근용입니다. 우리 API 인증을 위해 아래 중 하나를 선택하세요.

- JWT 발급(Stateless, DB 없이 잘 맞음)
  - payload 예: `sub=<kakao_user_id>`, `provider="kakao"`, `iat/exp`
  - 만료 짧게(예: 15m~1h) + Refresh Token 전략은 선택

- 세션 쿠키(서버 상태 필요)
  - DB 없이 하려면 메모리 세션은 서버 재시작/스케일아웃에 취약
  - DB/Redis 없이 장기 운영은 비추

> 이 저장소가 FastAPI 구조인 만큼, **JWT 방식이 가장 자연스럽습니다.**

### 4.3 “DB 없이” 사용자 프로필을 어떻게 다루나?

선택지:

1. 최소 정보만 JWT에 담기(비추: 개인정보/변경 이슈)
2. 프론트가 사용자 프로필을 들고 있고, 백엔드는 ID만 신뢰
3. 필요할 때마다 카카오 API로 조회(쿼터/성능 비용)

실무적으로는 **ID만 JWT에 담고**, 닉네임/프로필은 화면에서 필요할 때 프론트가 카카오로부터 얻는 방식으로 시작합니다.

---

## 5) 로그아웃/연결해제(unlink) 개념

- 우리 서비스 로그아웃
  - 우리 JWT를 폐기(클라이언트 삭제)
  - 서버는 DB가 없으면 블랙리스트 관리가 어려움 → JWT 만료를 짧게 가져가거나(권장) Redis 같은 저장소를 도입

- 카카오 로그아웃(카카오 토큰 무효화)
  - 카카오 제공 로그아웃 API/SDK 활용

- 연결해제(unlink)
  - “이 앱과 카카오 계정 연결 끊기”
  - 회원 탈퇴에 해당하는 UX를 만들 때 사용

---

## 6) 보안/운영 체크리스트

- **키 관리**
  - JavaScript 키는 프론트에 노출되어도 괜찮지만, 도메인/Redirect URI 등록으로 통제
  - REST/Admin 키는 서버 전용. `.env`로 관리하고 깃 커밋 금지

- **토큰 취급**
  - 카카오 `access_token`을 로깅 금지
  - 우리 서비스 인증은 우리 JWT로

- **CORS/HTTPS**
  - 운영은 HTTPS 강제
  - 프론트 도메인을 CORS에 명시

- **에러 처리 UX**
  - `access_token` 만료 시: 프론트에서 재로그인

---

## 7) 추천 “최소 API 설계” (나중에 코드로 만들 때)

DB 없이 시작할 때 백엔드에 흔히 만드는 엔드포인트 예시는 다음입니다.

- `POST /auth/kakao`
  - 입력: `kakao_access_token`
  - 동작: `GET /v2/user/me`로 검증 후 우리 JWT 발급

- `GET /me`
  - 입력: `Authorization: Bearer <our_jwt>`
  - 출력: `kakao_user_id` (필요 최소)

- (선택) `POST /auth/logout`
  - DB 없으면 사실상 클라이언트 토큰 삭제 안내

---

## 8) 자주 막히는 부분

- **"DB 없이"인데 사용자별 기능이 필요해짐**
  - 즐겨찾기/히스토리/설정이 필요해지는 순간 최소 저장소가 필요합니다.
  - 가벼운 시작: SQLite
  - 운영: PostgreSQL + 마이그레이션(Alembic)

- **닉네임/이메일을 JWT에 넣어도 되나?**
  - 가능은 하지만 권장하지 않습니다(변경/노출/동기화 문제).
  - 최소한의 식별자(`kakao_user_id`)만 JWT에 넣는 것이 안전합니다.

- **개발/운영 도메인 다름**
  - 카카오 콘솔 플랫폼/Redirect URI를 환경별로 모두 등록해야 합니다.

---

## 9) 다음 단계(원하면 제가 이어서 작업 가능)

원하시면, 이 백엔드(FastAPI)에 맞춰 아래까지 실제 코드로 붙여드릴 수 있습니다.

- `/auth/kakao` 라우터 추가
- 카카오 `user/me` 검증 로직(HTTP client)
- 우리 JWT 발급/검증(이미 있는 `app/core/security.py` 활용 여부 확인)
- CORS 설정 및 환경변수 정리

원하시는 로그인 흐름이 **A안(프론트 토큰 전달)** 인지 **B안(서버에서 code 교환)** 인지 알려주시면 그 방식으로 맞춰서 구현 계획을 잡아드릴게요.
